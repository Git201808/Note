# 6. 类型转换

**回顾**

### 1. 常量

常量是一个值：固定不变，是基本类型的值都可以认为是常量

在程序运行的过称中不能再次发生改变

String类 引用数据类型 值“abc” 视为常量

常量存储在常量缓冲区（常量池）中，有且只有一份

常量池中的值默认空间大小 32bit---bit	64bit--double

### 2. 变量

变量是一 个内存空间（小容器）

在栈内存中开辟一块内存空间

空间在开辟（变量声明）必须指定类型 名字（规则规约）

变量空间内容有且只有一个（只能存一份 值 引用）

空间内的内容的类型与定义时一致 内容可以改变

声明变量时需要注意的问题

float x = 3.4F;

long y = 2147483648L://如果超过int的取值范围2147483648，需要加L

### 3. 内存结构与执行过程

类的定义 编译 加载 空间各个区 变量 赋值

------

数据类型之间的转化问题

```java
int a = 1;
int b = 1;
int b = a;
----------
byte a = 1;
int b = a;
```

整形

byte(8bit)	short(16bit)	int(32bit)	long(64bit)

浮点

float(16bit)	double(32bit)

字符

char(16bit)

布尔

boolean(true/false)

## 类型之间的转换问题

1. 同种数据类型之间是可以直接进行赋值操作

2. 数据类型不同的空间 之间的赋值--->转换问题

   - 同种大数据类型之间才能发生转换

   - 基本类型---基本类型之间	可以直接转换（自动	强制）

   - 引用类型---引用类型之间	可以直接转换（自动	强制--上转型 下转型）

   - 基本类型---引用类型之间	不可以直接转换（间接--包装类/封装类）

3. 保证大数据类型一致的前提下

   - 基本类型--基本类型

     ​	小数据类型相同

     ​		都是整数 都是浮点

     ​			byte a =1;	int b = a;//自动直接转化就可以，小类型放到大类型了，直接放就是

     ​			int a = 1;byte b = a;//需要强制类型转换，大类型放到小类型里，需强制

     ​			float x=3.4F;	double y = x;//自动直接转换

     ​			double x = 3.4;float y = (float)x;//强制转换

     ​			如果发现强制转换之前的数值比较大 强制转化这件事可用的，执行后值一定发生改变。

     ​			int a = 1000;byte b = a

     ​	小数据类型不同

   - 引用类型之间后续...



## 进制转换

00000000 00000000 00000000 00000000

十进制-->二进制 除以2取余数 余数倒序排列

