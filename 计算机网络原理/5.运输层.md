# 运输层-两个主机之间的数据传输服务

## 5.1 运输层协议概述

物理层、链路层-网卡、网络层-路由器

### 5.1.1 进程之间的通信

- 从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，**它属于面向通信部分的最高层，同时也是用户功能中的最低层。**

- 当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，**只有位于网络边缘核边缘部分的主机的协议栈才有运输层**，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。

  **运输层为相互通信的应用进程提供了逻辑通信 **

#### 运输层的作用

- “**逻辑通信**“的意思是”好像是这样通信，但事实上并非真的这样通信“。
- **从IP层来说，通信的两端是两台主机。**但“两台主机之间的通信”这种说法还不够清楚。
- 严格地讲，两台主机进行通信就是两台主机中的应用进程互相通信。
- **从运输层的角度看，通信的真正端点并不是主机而主机中的进程。**也就是说，端到端的通信是应用进程之间的通信。

------

- 在一台主机中经常有**多个应用进程**同时分别和另一台主机中的多个应用进程通信。
- 这表明运输层有一个很重要的功能——**复用(**multiplexing)和**分用**(demultiplexing)。(基于端口的复用和分用功能)
- 根据应用程序的不同需求，运输层需要有两种不同的运输协议，即**面向连接的TCP**和**无线连接的UDP**

#### 网络层和运输层有明显的区别

网络层是为主机之间提供逻辑 通信，而运输层为应用进程之间提供端到端的逻辑通信。 

#### 屏蔽作用

- 运输层向高层用户**屏蔽**了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等），它使用进程看见的就是好像在两个运输层实体之间有一条**端到端的逻辑通信信道。**

### 两种不同的运输协议

- 但这条逻辑通信信道对上层的表现却因运输层使用的不同协议而有很大的差别。
- 当运输层采用面向连接的**TCP**协议时，尽管下面的网络是不可靠的（只提供尽大努力服务），但这种逻辑通信信道就相当于一条全**双工的可靠信道**。
- 当运输层采用无连接的**UDP**协议时，这种逻辑通信信道是一条**不可靠信道**。

### 5.1.2 运输层的两个主要协议

**TCP/IP的运输层有两个主要协议：**

- (1) **用户数据报协议UDP**(User Datagram Protocol)
- (2) **传输控制协议TCP**(Transmission Control Protocol)



#### TCP与UDP

- 两个对等运输实体在通信时传送的数据单位叫作**运输协议数据单元**TPDU(Transport Protocol Data Unit)。
- TCP传送的数据单位协议是**TCP报文段**(segment)。
- UDP传送的数据单位协议是**UDP报文**或**用数据报**。
- UDP:一种无连接协议
  - 提供无连接服务。
  - **在传送数据之前不需要先建立连接**。
  - 传送的数据单位协议是**UDP报文**或**用户数据报**。
  - 对方是运输层在收到UDP报文后，不需要给出任何确认。
  - 虽然**UDP不提供可靠交付**，但在某些情况小UDP是一种最有效的工作方式。

**！！！还要强调两点**

- 运输层的UDP用户数据报与网际的IP数据报有很大区别。
  - IP数据报要经过互联网中许多路由器的存储转发。
  - UDP用户数据报是在运输层的端到端抽象的逻辑信道中传送的。
-  TCP报文段是运输层抽象的端到端逻辑信道中传送，这种信道是可靠的全双工信道。但这样的信道却不知道究竟经过了哪些路由器，而这些路由器也根本不知道上面的运输层是否建立了TCP连接。

### 5.1.3 运输层的端口

- 运行在计算机中的进程是用**进程标识符**来标志的。
- **但运行在应用层的各种应用进程却不应当让计算机操作系统指派它的进程标识符。**这是因为在互联网上使用的计算机的操作系统种类很多，而不同的操作系统又使用不同格式的进程标识符。
- 为了使运行不同操作系统的计算机的应用进程能够互相通信，就**必须用统一的方法**对TCP/IP体系的应用进程进行标志。

#### 需要解决的问题

- 由于进程的创建和撤销都是动态的，发送方几乎无法识别其他机器上的进程。
- 有时我们会改换接收报文的进 程，但并不需要通知所有的发送方。
- 我们往往需要利用目的主机提供的功能来识别终点，而不需要知道实现这个功能的进程。

#### 端口号(protocol port number)

- 解决这个问题的方法就是在运输层使用**协议端口号**(protocol port number),或通常简称为**端口**(port)。
- 虽然通信的终点是应用进程，但我们可以把端口想象是通信的终点，因为我们只要把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由TCP来完成。

#### 软件端口与硬件端口

- 两个不同的概念。
- 在协议栈层间的抽象的协议端口是**软件端口**。
- 路由器或交换机上的端口是**硬件端口**。
- 硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址。

#### TCP/IP运输层端口

- 端口用一个16位端口号进行标志。

- 端口号只具有**本地意义**，即端口号只是为了标志**本计算机应用层中的各进程**。

- 在互联网中，不同的计算机的相同端口号是没有联系的。

  **由此可见，两个计算机中的进程要互相通信，不进必须知道对方的IP地址（为了找到对方的计算机），而且还要知道对方的端口号（为了找到对方计算机中的应用进程）。**

#### 两大类端口

(1) 服务器端使用的端口号

- **熟知端口**，数值一般为 0~1023。
- **登记端口号**，数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在IANA登记，以防止重复。

(2) 客户端使用的端口号

- **又称为短暂端口号**，数值为49152~65535，留给客户进程选择暂时使用。
- 当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后这个端口号可供其他客户进程以后使用。

## 5.2 用户数据报协议UDP

### 5.2.1 UDP概述

- UDP只在IP数据报服务之上增加了很少一点的功能：
  - 复用和分用的功能
  - 差错检测的功能
- 虽然UDP用户数据报只能提供不可靠的交付，但UDP在某些方面有其特殊的优点。

#### UDP的主要特点

- (1) **UDP是无连接的**，发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。。
- (2) **UDP使用尽最大努力交付**，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。
- (3) **UDP是面向报文的**。UDP对应用层交下来的报文，即不合并，也不拆分，而是保留这些报文的边界。UDP一次交付一个完整的报文。
- (4) **UDP没有拥塞控制**，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很适合多媒体通信的要求。
- (5)UDP支持一对一、一对多、多对一和多对多的交互通信。
- (6) UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。

#### 面向报文的UDP

- 发送方UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，疾合并，也不拆分，而是保留这些报文的边界。
- 应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。
- 接收方UDP对IP层交上来的UDP用户数据报，在去除首部后就原封不动地交付上层的应用进程，**一次交付一个完整的报文**。
- 应用程序必须选择**合适大小的报文**。
  - **若报文太长**，UDP把它交给IP层后，IP层在传送时可能要进行分片，这会降低IP层的效率。
  - **若报文太短**，UDP把它交给IP层后，会使IP数据报的首部的相对长度太大，这也降低了IP层的效率。

### 5.2.2 UDP的首部格式

**用户数据报UDP有两个字段：数据字段和首部字段。首部字段很简单，只有8个字节。**



#### UDP基于端口的分用

**当运输层从IP层收到UDP数据报时，就根据首部中的目的端口，把UDP数据报通过相应的端口，上交最后的终点——应用进程。**

## 5.3 传输控制协议TCP概述

### 5.3.1 TCP最主要的特点

- TCP是**面向连接**的运输层协议。
- 每一条TCP连接**只能有两个端点**(endpoint)，每一条TCP连接**只能是点对点**的(一对一)。
- TCP提供**可靠交付**的服务。
- TCP提供**全双工**通信。
- **面向字节流**
  - TCP中的“**流**”(stream)指的是流入或流出进程的字节序列。
  - **“面向字节流”的含义是**：虽然应用程序和TCP的交互是一次一个数据块，但TCP把应用程序交下来的数据看成仅仅是一连串无结构的字节流。

#### TCP面向流的概念

- TCP**不保证**接收的方应用程序所收到的数据块和发送应用所发出的**数据块具有对应大小的关系**。

- 但接收方应用程序收到的字节流必须和发送方应用程序发出的**字节流完全一样**。

  **TCP不关心应用进程一次把多长的报文发送到TCP缓存。**

  **TCP对连续的字节流进行分段，形成TCP报文段。**
  

**！！！注意**

- TCP连接是一条**虚连接**而不是一条真正的物理连接
- TCP对应用进程一次把多长的报文发送到TCP的缓存中是不关心的。
- TCP根据对方给出的**窗口值**和**当前网络拥塞**的程度来决定一个报文段应包含多少个字节(UDP发送的报文长度是应用进程给出的)。
- TCP可把太长的数据块划分短一些再传送。
- TCP也可等待积累有足够多的字节后再构成报文段发送出去。

### 5.3.2 TCP的连接

- TCP把连接作为**最基本的抽象。**

- 每一条TCP连接**有两个端点**。

- TCP连接的端点不是主机，不是主机的IP地址，不是应用进程，也不是运输层的协议端口。

  **TCP连接的端点叫做套接字(socket)或插口。**

- **端口号拼接到(contatenated with) IP 地址即构成了套接字。**

-------

**套接字(socket)** 

**套接字socket=(IP地址：端口号)**

每一条TCP连接唯一的被通信两端的两个端点（即两个套接字）所确定。即：

```
TCP连接::={socket1,socket2}
		={(IP1:port1),(IP2:port2)}
```

-------

#### TCP连接，IP地址，套接字

- TCP连接就是由协议软件所提供的一种抽象。
- TCP连接的端点是个很抽象的套接字，即(IP地址:端口号)。
- 同一个IP地址可以有多个不同的TCP连接。
- 同一个端口号也可以出现多个不同的TCP连接中。

------

#### Sockeet有多种不同的意思

- 应用编程接口 API 称为socket API，简称为socket.
- socket API中使用的一个函数名也叫作socket
- 调用socket函数的端点称为socket。
- 调用socket函数时其返回值称为socket描述符，可简称为socket。
- 在操作系统内核中连网协议的Berkeley实现，称为socket实现。 

## 5.4 可靠传输的工作原理

#### 理想的传输条件特点

- 理想的传输条件有以下**两个特点**：
  - (1) 传输信道不产生差错。
  - (2) 不管发送方以多块的速度发送数据，接收方总是来得及处理收到的数据。
- 在这样的理想传输条件下，不需要采取任何措施就能够实现可靠传输。
- **然而实际的网络都不具备以上两个理想条件**。必须使用一些可靠传输协议，在不可靠的传输信道实现可靠传输。

### 5.4.1 停止等待协议

- “停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。
- **全双工通信的双方既是发送方也是接收方。**
- 为了讨论问题的方便，我们仅考虑A发送数据而B接收数据并发送确认。因此A叫作**发送方**而B叫作**接收方**。

------

#### 1.无差错的情况

**A发送分组M1，发完就暂停发送，等待B的确认(ACK).B收到了M1向A发送ACK。A在收到了对M1的确认后，再发送下一个分组M2。**

#### 2. 出现差错

- 在接收方B会出现两种情况：
  - **B接收M1时检测出了差错**，就丢弃M1，其他什么也不做（不通知A收到有差错的分组）。
  - **M1在传输过程中丢失了**，这时B当然什么都不知道，也什么都不做。
- **在这两种情况下，B都不会发送任何信息**。
- 如何保证B正确收到了M1呢？
- 解决方法：**超时重传**
  - A为每一个已发送的分组都设置了一个**超时计时器**。
  - A只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组M2。

#### 3. 确认丢失和确认迟到

- **确认丢失**
  - 若B所发送的对M1的确认丢失了，那么A在设定的超时重传时间内不能收到确任，但A并无法知道：是自己发送的分组出错、丢失了，**或者**是B发送的确认丢失了，因此**A在超时计时器到期后就要重传M1**。
  - 假定B又收到了重传的分组M1。这时B应采取两个行动。
    - 第一，**丢弃**这个重复的分组M1，不向上层交付。
    - 第二，**向A发送确认**。不能认为已经发送过确认就不再发送，因为A之所以重传M1就表示A没有收到对M1的确认。
- **确认迟到**
  - 传输过程中没有出现差错，但B对分组M1的确认迟到了。
  - A会收到重复的确认。对重复的确认的处理很简单：收下后就丢弃。
  - B仍然后收到重复的M1，并且同样要丢齐重复的M1，并重传确认分组。

### 5.4.2 连接ARQ协议

- 滑动窗口协议比较复杂，是TCP协议的精髓所在。
- 发送方维持的**发送窗口**，它的意义是：**位于发送窗口内的分组都可连接发送出去，而不需要等待对方的确认**。这样，信道利用率就提高了。
- 连接ARQ协议规定，**发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。**

#### 累积确认

- 接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对顺序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都正确收到了。
- 优点：容易实现，即使确认丢失也不必重传。
- 缺点：不能向发送方反映出接收方已经正确收到的所有分组信息。

#### Go-back-N（回退N）

- 如果发送方发送了前5个分组，而中间的第3个分组丢失了。 这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而**只好把后面的三个分组都再重传一次**。
- 这就叫作Go-bakc-N（**回退N**），**表示需要再退回来重传已发送过的N个分组**。
- 可见当通信线路质量不好时，连续ARQ协议会带来负面的影响。

#### TCP可靠通信的具体实现

- TCP连接的每一端都必须设有两个窗口——一个**发送窗口**和一个**接收窗口**。

- TCP的可靠传输机制用**字节的序号**进行控制。

  TCP所有的确认都是基于序号而不是基与报文段。

- TCP两端的四个窗口经常处于**动态变化**之中。

- TCP连接的往返时间RTT也不是固定不变的。需要使用特定的算法**估算较为合理的重传时间**。

## 5.5 TCP报文段的首部格式

- TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段。
- 一个TCP报文段分为首部和数据两部分，而TCP的全部功能体现在它首部中各字段的作用。
- TCP报文段首部的前20个字节是固定的，后面有4n字节是根据需要而增加的选项（n是整数）。**因此TCP首部的最小长度是20字节**。

------

**源段口**和**目的端口**字段——各占2字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。

**序号字段**——占4字节。TCP连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。

**确认号字段**——占4字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。

**数据偏移（即首部长度）**——占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。“数据偏移”的单位是32位字（以4字节为计算单位）。 

**保留字段**——占6位，保留为今后使用，但目前应置为0。

紧急URG——当URG=1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据）。

确认ACK——只有当ACK=1时确认号字段才有效。当ACK=0时，确认号无效。

推送PSH(PuSH)——接收TCP收到PSH=1的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。

复位RST(ReSeT)——当RST=1时，表明TCP连接中出现严重差错(如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接。

同步SYN——同步SYN=1表示这是一个连接请求或连接受报文。

终止FIN(FINish)—— 用来释放一个连接。FIN=1表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。

窗口字段——占2个字节，用来让对方设置发送窗口的依据，单位为字节。

**检验和**——占2个字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。

**紧急指针字段**——占16位，指出在本段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。

**选项字段**——长度可变。TCP最初只规定了一种选项，即**最大报文段长度MSS**。MSS告诉对方TCP：我的缓存所能接收的报文段的数据字段的最大长度是MSS个字节。

**填充字段**——这是为了使整个首部长度是4字节的整是倍。

-----

#### 为什么要规定MSS？

- **MSS与接收窗口值没有关系**。
- **若选择较小的MSS长度，网络的利用率就降低。**
- 当TCP报文段**只含有1字节的数据时**，在IP层传输的数据报的开销至少有40字节（包括TCP报文段的首部和IP数据报的首部）。这样，对网络的利用率就不超过1/41。到了数据链路层还要加上一些开销。
- 若**TCP报文段非常长**，那么在IP层传输时就有可能要分解成多个短数据报片。在终点要把收到的各个短数据报片装配成原来的TCP报文段。当传输出错时还要进行重传。这些也都会使开销增大。

#### 为什么要规定MSS？

- 因此，MSS应尽可能大些，只要在IP层传输时不需要再分片就行。
- 由于IP数据报所经历的路径是动态变化的，因此在这条路径上确定的不需要分片的MSS，如果改走另一条路径就可能需要进行分片。
- 因此**最佳的MSS是很难确定的**。

#### 其他选项

- 窗口扩大选项——占3字节，其有一个字节表示移位值S。新的窗口值等于TCP首部中的窗口位属增大到（16+S），相当于把窗口值向左移动S位后获得实际的窗口大小。
- 时间vo选项——占10字节，其中最主要的字段时间lu字段（4字节）和时间lu回送字段（4字节）。
- 选择确认选项——在后面的5.6.3节介绍。 

## 5.6 TCP可靠传输的实现

### 5.6.1 以字节为单位的滑动窗口  

- TCP的滑动窗口是以字节为单位的。
- 现假定A收到了B发来的确认文段，其中窗口是20字节，而确认号是31（这表明B期望收到的下一个序号是31，而序号30为止的数据已经收到了）。
- 根据这两个数据，A就构造出自己的发送窗口

#### 发送缓存与接收缓存的作用

- 发送缓存用来暂时存放：
  - 发送应用程序传送给发送方TCP准备发送的数据;
  - TCP已发送但尚未收到确认的数据。
- 接收缓存用来暂时存放：
  - 按序到达的、但尚未被接收应用程序读取的数据;
  - 不按序到达的数据。

------

#### 需要强调三点

- 第一，A的发送窗口不总是和B的接收窗口一样大（因为有一定的时间滞后）。
- 第二，TCP标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层应用进程。
- 第三，TCP要求接收方必须有累积确认的功能，这样可以减少开销。

#### 接收方发送确认

- 接收方可以在**合适的时候发送确认**，也可以在自己有数据要发送时把确认信息**顺便捎带上**。
- 但请注意两点：
  - 第一，接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，这反而浪费了网络的资源。
  - 第二，捎带确认实际上并不经常发生，因为大多数应用称序很少同时在两个方向上发送数据。

### 5.6.2 超时重传时间的选择

- 重传机制是TCP中最重要和最复杂的问题之一。
- TCP每发送一个报文段，就对一个报文段设置一次计时器。
- 只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。
- **重传时间的选择是TCP最复杂的问题之一。**

### 5.6.3 选择确认SACK

- **问题：**若收到的报文无差错，只时未按序号，中间还缺少一些序号的数据，那么能否设法只传送缺少的的数据而不重传已经正确到达的接收方的数据？
- 答案是可以的。**选择确认SACK(Selective ACK)**就是一种可行的处理方法。
- 接收方收到了和前面的字节流不连续的两个字节块。
- 如果这些字接的序号都在接收窗口之内，那么接收方就**先收下**这些数据，**但要把这些信息准确的告诉发送方，使发送方不要再重复发送这些已收到的数据**。

## 5.7 TCP的流量控制

### 5.7.1 利用滑动窗口实现流量控制

- 一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。
- **流量控制(flow control)**就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。
- 利用**滑动窗口机制**可以很方便的在TCP连接上实现流量控制。

------

#### 可能发生死锁

- B向A发送了零窗口的报文段后不久，B的接收缓存又有了一些存储空间。于是B向A发送了rwnd=400的报文段。
- 但这报文段在传送过程中**丢失**了。A一直等待收到B发送的非零窗口的通知，而B也一直等待A发送的数据。
- 如果没有其他措施，这种**互相等待的死锁**局面将一直延续下去。
- 为了解决这个问题，TCP为每一个连续设有一个**持续计时器**(persistence timer)。 

##### 持续计时器

- TCP为每一个连接设有一个**持续计时器**(persistence timer)
- 只要TCP连接的一方收到对方的**零窗口**通知，就启动该持续计时器。
- 若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带1字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。
- 若窗口仍然为零，则收到的这个报文段的一方就重新设置持续计时器。
- 若窗口不是零，则死锁的僵局就可以打破了。

### 5.7.2 TCP的传输效率

- 可以用不同的机制来控制TCP报文段的发送时机：
  - **第一种机制**是TCP维持一个变量，它等与最大报文段长度MSS。只要缓存中存放的数据达到MSS字节时，就组装成一个TCP报文段发送出去。
  - **第二种机制**是由发送方的应用进程指明要求发送报文段，即TCP支持的**推送(**push)操作。
  - **第三种机制**是发送方的一个计时器限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过MSS）发送出去。 
- 如何控制TCP发送报文段的时机仍然是一个较为复杂的问题。

------

#### 发送方糊涂窗口综合症

- 发送方TCP每次接收到一字节的数据后就发送。
- 这样，发送一个字节需要形成41字节长的IP数据报。若接收方确认，并回送这一字节，就需要传送总长度为162字节共4个报文段。效率很低。
- **解决方法：**使用**Nagle算法。**

##### Nagle算法

- 若发送应用进程把要发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面到达的数据字节都缓存起来。
- 当发送方收到对第一个数据字符的确认后，再把发送缓存中的所有数据组装成一个报文段发送出去，同时继续对随后到达的数据进行缓存。
- 只有在收到对前一个报文段的确认后才继续发送下一个报文段。
- 当到达的数据已达到发送窗口大小的一半或已达到报文段的最大长度时就立即发送一个报文段。

## 5.8 TCP的拥塞控制

### 5.8.1 拥塞控制的一般原理

- 在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这中现象称为**拥塞(congestion)**。

- 若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。

- 出现拥塞的**原因**：

  **对资源需求 > 可用资源**

-------

增加资源能解决拥塞吗？不能，能一定程度有所缓解，不能根本解决。网络拥塞往往是多因素引起的。

- 增大缓存，但未提高输出链路的容量和处理机的速度。排对等待时间会大大增加，引起大量超时重传，解决不了网络拥塞。

- 提高处理机的速率会会将瓶颈转移到其他地方。

#### 拥塞常常趋于恶化

- 如果一个路由器没有足够的缓存空间，它就会丢弃一些新到的分组。
- 但当分组被丢弃时，发送这一分组的源点就会重传这一分组，甚至可能还要重传多次。这样会引起更多的分组流入网络和被网络中的路由器丢弃。
- **可见拥塞引起的重传并不会缓解网络的拥塞，反而会加剧网络的拥塞。**



#### 拥塞控制与流量控制的区别

- **拥塞控制**就是防止过多的数据注入到网络中，使网络中的路由器或链路不致过载。
- **拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷**。
- **拥塞控制**是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。
- **流量控制**往往指点对点通信量的控制，是个端对端的问题（接收端控制发送端）。
- **流量控制**所要做的就是抑制发送数据的速率，以便使接收端来得及接收。

**拥塞控制和流量控制之所以常常被弄混，是因为某些控塞控制算法是向发送控制报文，并告诉发送端，网络已出现麻烦，必须放慢发送速率。这点又和流量控制是相似的。**

------

#### 拥塞控制的一般原理

- 实践证明，拥塞控制是很难设计的，因为它是一个**动态**的（而不是静态的）**问题**。
- 当前网络正朝着高速化的方向发展，这很容易出现缓存不够大而造成分组的丢失。**但分组的丢失是网络发生拥塞的征兆而不是原因**。
- **在许多情况下，甚至正是拥塞控制本身成为引起网络性能恶化甚至发生死锁的原因**。这点应特别引起重视。

#### 开环控制和闭环控制

- 开环控制方法就是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。
- 闭环控制方法是基于反馈环路的概念。属于闭环控制的有以下几种措施：
  - (1)检测网络系统以便检测到拥塞在何时、何处发生。
  - (2) 将拥塞发生的信息传送到可采取行动的地方。
  - (3) 调整网络系统的运行以解决出现的问题。

#### 监测网络的拥塞的指标

- 主要指标有：
  - 由于缺少缓存空间而被丢弃的分组的百分数;
  - 平均队列长度
  - 超时重传的分组数;
  - 平均分组时延
  - 分组时延的标准差，等等。
- 上述这些指标的上升都标志这拥塞的增长。

### 5.8.2 TCP的拥塞控制方法

- TCP采用基于窗口进行拥塞控制。该方法属于闭环控制方法。

- TCP发送方维持一个拥塞窗口CWND(Conestion Window)

  - 拥塞窗口的大小取决与网络 的拥塞程度，并且动态地在变化。

  - 发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。

  - 所以，发送窗口大小不仅取决于接收方公告的接收窗口，还取决于网络的拥塞状况，所以真正的发送窗口值为：

    **真正的发送窗口值=Min(公告窗口值，拥塞窗口值)**

#### 控制拥塞窗口的原则

- 只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去， 这样就可以提高网络的利用率。
- 但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减少一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。

#### 拥塞的判断

- 重传定时器超时
  - 现在通信线路的传输质量一般都很好，因传输出差错而丢失分组的概率是很小的（远小与1%）。只要出现了超时，就可以猜想网络可能出现了拥塞。
- 收到三个相同（重复）的OK
  - 个别报文段会在网络中丢失

--------

#### TCP拥塞控制算法

- 四种(RFC 5681)
  - 慢开始(slow-start)
    - 用来确认网络的负载能力。
    - **算法的思路：由小到大逐渐增大拥塞窗口数值**。
    - **初始拥塞窗口cwnd设置**：
      - 旧的规定：在刚刚开始发送报文段时，先把初始拥塞窗口cwnd设置为1至2个发送方的最大报文段SMSS(Sender Maximum Segment Size)的数值。
      - 新的RFC 5681 把初始拥塞窗口cwnd设置为不超过2至4个SMSS的数值。
    - **慢开门限ssthresh(状态变量)**：防止拥塞窗口cwnd增长过大引起网络拥塞。
    
  - 拥塞避免(congestion avoidance)
  
    - 思路：让拥塞窗口cwnd**缓慢地增大**，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，使拥塞窗口cwnd**按线性规律缓慢增长**。
    - 因此拥塞避免阶段就有“**加法增大**”(Additive Increase)的特点。这表明在拥塞避免阶段，拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。
  
  - 快重传(fast retransmit)
  
    - 采用**快重传**FR(Fast Retransmission)算法可以让发送方**尽早知道发生了个别报文段的丢失**。
  
    - **快重传**算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。
  
    - **发送方只要一连收到三个重复确认**，就知道接收方确实没有收到报文段，因而应当**立即进行重传(即“快重传“)**，这样就不会出现超时发送方也不就会误认为出现了网络拥塞。
  
    - 使用快重传可以使整个网络的吞吐量提高约20%。
  
      **不难看出，快重传并非取消重传计时器，而是在某些情况下可<u>更早地重传</u>丢失的报文段。**
  
  - 快恢复(fast recovery)
  
    - 当发送端收到连续的三个重复的确认时，由于发送方现在认为网络很可能没有发生拥塞，因此现在**不执行慢开始算法**，而是执行**快恢复算法**FR(Fast Recoverry)算法：
  
      (1) 慢开始门限ssthresh = 当前拥塞窗口 cwnd / 2;
  
      (2) 新拥塞窗口 cwnd = 慢开始门限 ssthresh;
  
      (3) 开始执行拥塞避免算法，使拥塞窗口缓慢的线性增大。

------

### 当网络出现拥塞时

- 无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞(**重传定时器超时**)：
  - ssthresh = max(cwnd/2,2)
  - cwnd = 1
  - 执行慢开始算法
- 这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理 完毕。

#### 必须强调指出

- “拥塞避免” 并非指完全能够避免了拥塞。利用以上的措施完全避免网络拥塞是不可能的。
- “拥塞避免”是说在拥塞避免阶段把拥塞窗口控制为按线性规律增长，**使网络比较不容易出现拥塞**。

#### 加法增大，乘法减小(AIMD)

- 可以看出，在拥塞避免阶段，拥塞窗口是按照线性规律增大的。这常程为“加法增大”AI (Additive Increase)。
- 当出现超时或3个重复的确认时，就要把门限值设置为当前拥塞窗口值的一半，并大大减小拥塞窗口的数值。这常称为“乘法减小”MD (Multiplicative Decrease)。
- 二者合在一起就是所谓的AIMD算法。

#### 发送窗口的上限值

- 发送方的发送窗口的上限值应当取为接收方窗口rwnd和拥塞窗口cwnd这两个变量中较小的一个，即应按以下公式确定：

  **发送窗口的上限值= Min[rwnd, cwnd]**

- 当rwnd< cwnd时，时接收方的接收能力限制发送窗口的最大值。

- 当cwnd>rwnd时，则是网络的拥塞限制发送窗口的最大值。

### 5.8.3 主动队列管理AQW

## 5.9 TCP的运输连接管理（tcp的三次握手)

### 运输连接的三个阶段

- TCP面向连接的协议。
- 运输连接有三个阶段：
  - **连接建立**
  - **数据传送**
  - **连接释放**
- **运输连接的管理**就是使运输连接的建立和释放都能正常的进行。

------

#### TCP连接建立过程中要解决的三个问题

- (1)要使每一方能够确知对方的存在
- (2)要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选择以及服务质量等）。
- (3)能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。

#### 客户-服务器方式

- TCP连接的建立**采用客户服务器方式**。

- 主动发起连接建立的应用程序叫做**客户**(client)

- 被动等待连接建立的应用进程叫作**服务器**(server)。

### 5.9.1 TCP的连接建立

- TCP建立连接的过程叫做**握手**。
- 握少需要在客户和服务器之间交换三个TCP报文段。称之为**三报文握手**。
- 采用**三报文握手**主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。

### 5.9.2 TCP的连接释放

- TCP连接释放过程比较复杂。
- 数据传输结束后，通信的双方都可释放连接。
- TCP连接释放的过程是**四报文握手**。

#### A必须等待2MSL的时间

- 第一，为了保证A发送的最后一个ACK报文段能够到达B。
- 第二，防止“已失效的连接请求报为段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

### 5.9.3 TCP的有限状态机

